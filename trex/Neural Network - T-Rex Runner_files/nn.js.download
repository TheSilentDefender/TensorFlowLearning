/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	function webpackJsonpCallback(data) {
/******/ 		var chunkIds = data[0];
/******/ 		var moreModules = data[1];
/******/ 		var executeModules = data[2];
/******/
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(data);
/******/
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 		// add entry modules from loaded chunk to deferred list
/******/ 		deferredModules.push.apply(deferredModules, executeModules || []);
/******/
/******/ 		// run deferred modules when all chunks ready
/******/ 		return checkDeferredModules();
/******/ 	};
/******/ 	function checkDeferredModules() {
/******/ 		var result;
/******/ 		for(var i = 0; i < deferredModules.length; i++) {
/******/ 			var deferredModule = deferredModules[i];
/******/ 			var fulfilled = true;
/******/ 			for(var j = 1; j < deferredModule.length; j++) {
/******/ 				var depId = deferredModule[j];
/******/ 				if(installedChunks[depId] !== 0) fulfilled = false;
/******/ 			}
/******/ 			if(fulfilled) {
/******/ 				deferredModules.splice(i--, 1);
/******/ 				result = __webpack_require__(__webpack_require__.s = deferredModule[0]);
/******/ 			}
/******/ 		}
/******/
/******/ 		return result;
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// Promise = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		"nn": 0
/******/ 	};
/******/
/******/ 	var deferredModules = [];
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/assets";
/******/
/******/ 	var jsonpArray = window["webpackJsonp"] = window["webpackJsonp"] || [];
/******/ 	var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
/******/ 	jsonpArray.push = webpackJsonpCallback;
/******/ 	jsonpArray = jsonpArray.slice();
/******/ 	for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
/******/ 	var parentJsonpFunction = oldJsonpFunction;
/******/
/******/
/******/ 	// add entry module to deferred list
/******/ 	deferredModules.push([8,"vendor"]);
/******/ 	// run deferred modules when ready
/******/ 	return checkDeferredModules();
/******/ })
/************************************************************************/
/******/ ({

/***/ "../node_modules/css-loader/dist/cjs.js!../node_modules/less-loader/dist/cjs.js!./game/index.less":
/*!********************************************************************************************************!*\
  !*** ../node_modules/css-loader/dist/cjs.js!../node_modules/less-loader/dist/cjs.js!./game/index.less ***!
  \********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ \"../node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(false);\n// Module\n___CSS_LOADER_EXPORT___.push([module.i, \"html,\\nbody {\\n  padding: 0;\\n  margin: 0;\\n  width: 100%;\\n  height: 100%;\\n  font-family: -apple-system, BlinkMacSystemFont, \\\"Segoe UI\\\", Helvetica, Arial, sans-serif, \\\"Apple Color Emoji\\\", \\\"Segoe UI Emoji\\\", \\\"Segoe UI Symbol\\\";\\n}\\nh1 {\\n  font-size: 18px;\\n  font-weight: bold;\\n  text-align: center;\\n  margin-top: 20px;\\n  margin-bottom: 20px;\\n}\\n/* Offline page */\\n.page {\\n  margin-top: 20px;\\n  overflow: hidden;\\n}\\n.page .game {\\n  position: relative;\\n  color: #2b2b2b;\\n  font-size: 1em;\\n  margin: 0 auto;\\n  max-width: 600px;\\n  width: 100%;\\n  padding-top: 50px;\\n}\\n.page .game-canvas {\\n  height: 150px;\\n  max-width: 600px;\\n  opacity: 1;\\n  overflow: hidden;\\n  top: 0;\\n  z-index: 2;\\n}\\n.page .generation {\\n  position: absolute;\\n  top: 4px;\\n  left: 0;\\n  right: 0;\\n  font-weight: bold;\\n  text-align: center;\\n}\\n@media (max-height: 350px) {\\n  .game {\\n    margin-top: 5%;\\n  }\\n}\\n@media (min-width: 600px) and (max-width: 736px) and (orientation: landscape) {\\n  .page .game {\\n    margin-left: 0;\\n    margin-right: 0;\\n  }\\n}\\n@media (max-width: 240px) {\\n  .game {\\n    overflow: inherit;\\n    padding: 0 8px;\\n  }\\n}\\n\", \"\"]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack:///./game/index.less?../node_modules/css-loader/dist/cjs.js!../node_modules/less-loader/dist/cjs.js");

/***/ }),

/***/ "../node_modules/webpack/hot sync ^\\.\\/log$":
/*!***************************************************************!*\
  !*** ../node_modules/webpack/hot sync nonrecursive ^\.\/log$ ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var map = {\n\t\"./log\": \"../node_modules/webpack/hot/log.js\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"../node_modules/webpack/hot sync ^\\\\.\\\\/log$\";\n\n//# sourceURL=webpack:///../node_modules/webpack/hot_sync_nonrecursive_^\\.\\/log$?");

/***/ }),

/***/ "./ai/models/Model.js":
/*!****************************!*\
  !*** ./ai/models/Model.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _utils = __webpack_require__(/*! ../utils */ \"./ai/utils/index.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Model = function () {\n  function Model() {\n    _classCallCheck(this, Model);\n  }\n\n  _createClass(Model, [{\n    key: 'init',\n    value: function init() {\n      throw new Error('Abstract method must be implemented in the derived class.');\n    }\n  }, {\n    key: 'predict',\n    value: function predict(inputXs) {\n      throw new Error('Abstract method must be implemented in the derived class.');\n    }\n  }, {\n    key: 'predictSingle',\n    value: function predictSingle(inputX) {\n      return this.predict([inputX]);\n    }\n  }, {\n    key: 'train',\n    value: function train(inputXs, inputYs) {\n      throw new Error('Abstract method must be implemented in the derived class.');\n    }\n  }, {\n    key: 'fit',\n    value: function fit(inputXs, inputYs) {\n      var iterationCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;\n\n      for (var i = 0; i < iterationCount; i += 1) {\n        this.train(inputXs, inputYs);\n      }\n    }\n  }, {\n    key: 'loss',\n    value: function loss(predictedYs, labels) {\n      var meanSquareError = predictedYs.sub((0, _utils.tensor)(labels)).square().mean();\n      return meanSquareError;\n    }\n  }]);\n\n  return Model;\n}();\n\nexports.default = Model;\n\n//# sourceURL=webpack:///./ai/models/Model.js?");

/***/ }),

/***/ "./ai/models/nn/NNModel.js":
/*!*********************************!*\
  !*** ./ai/models/nn/NNModel.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _tfjs = __webpack_require__(/*! @tensorflow/tfjs */ \"../node_modules/@tensorflow/tfjs/dist/index.js\");\n\nvar tf = _interopRequireWildcard(_tfjs);\n\nvar _utils = __webpack_require__(/*! ../../utils */ \"./ai/utils/index.js\");\n\nvar _Model2 = __webpack_require__(/*! ../Model */ \"./ai/models/Model.js\");\n\nvar _Model3 = _interopRequireDefault(_Model2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\r\n * Simple Neural Network Model\r\n */\nvar NNModel = function (_Model) {\n  _inherits(NNModel, _Model);\n\n  function NNModel() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$inputSize = _ref.inputSize,\n        inputSize = _ref$inputSize === undefined ? 3 : _ref$inputSize,\n        _ref$hiddenLayerSize = _ref.hiddenLayerSize,\n        hiddenLayerSize = _ref$hiddenLayerSize === undefined ? inputSize * 2 : _ref$hiddenLayerSize,\n        _ref$outputSize = _ref.outputSize,\n        outputSize = _ref$outputSize === undefined ? 2 : _ref$outputSize,\n        _ref$learningRate = _ref.learningRate,\n        learningRate = _ref$learningRate === undefined ? 0.1 : _ref$learningRate;\n\n    _classCallCheck(this, NNModel);\n\n    var _this = _possibleConstructorReturn(this, (NNModel.__proto__ || Object.getPrototypeOf(NNModel)).call(this));\n\n    _this.weights = [];\n    _this.biases = [];\n\n    _this.hiddenLayerSize = hiddenLayerSize;\n    _this.inputSize = inputSize;\n    _this.outputSize = outputSize;\n    // Using ADAM optimizer\n    _this.optimizer = tf.train.adam(learningRate);\n    return _this;\n  }\n\n  _createClass(NNModel, [{\n    key: 'init',\n    value: function init() {\n      // Hidden layer\n      this.weights[0] = tf.variable(tf.randomNormal([this.inputSize, this.hiddenLayerSize]));\n      this.biases[0] = tf.variable(tf.scalar(Math.random()));\n      // Output layer\n      this.weights[1] = tf.variable(tf.randomNormal([this.hiddenLayerSize, this.outputSize]));\n      this.biases[1] = tf.variable(tf.scalar(Math.random()));\n    }\n  }, {\n    key: 'predict',\n    value: function predict(inputXs) {\n      var _this2 = this;\n\n      var x = (0, _utils.tensor)(inputXs);\n      var prediction = tf.tidy(function () {\n        var hiddenLayer = tf.sigmoid(x.matMul(_this2.weights[0]).add(_this2.biases[0]));\n        var outputLayer = tf.sigmoid(hiddenLayer.matMul(_this2.weights[1]).add(_this2.biases[1]));\n        return outputLayer;\n      });\n      return prediction;\n    }\n  }, {\n    key: 'train',\n    value: function train(inputXs, inputYs) {\n      var _this3 = this;\n\n      this.optimizer.minimize(function () {\n        var predictedYs = _this3.predict(inputXs);\n        return _this3.loss(predictedYs, inputYs);\n      });\n    }\n  }]);\n\n  return NNModel;\n}(_Model3.default);\n\nexports.default = NNModel;\n\n//# sourceURL=webpack:///./ai/models/nn/NNModel.js?");

/***/ }),

/***/ "./ai/utils/index.js":
/*!***************************!*\
  !*** ./ai/utils/index.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isTensor = isTensor;\nexports.tensor = tensor;\n\nvar _tfjs = __webpack_require__(/*! @tensorflow/tfjs */ \"../node_modules/@tensorflow/tfjs/dist/index.js\");\n\nvar tf = _interopRequireWildcard(_tfjs);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction isTensor(obj) {\n  return obj instanceof tf.Tensor;\n}\n\nfunction tensor(obj) {\n  if (obj instanceof tf.Tensor) {\n    return obj;\n  }\n  if (typeof obj === 'number') {\n    return tf.scalar(obj);\n  } else if (Array.isArray(obj)) {\n    return tf.tensor(obj);\n  }\n  throw new Error('tensor() only supports number or array as the input parameter.');\n}\n\n//# sourceURL=webpack:///./ai/utils/index.js?");

/***/ }),

/***/ "./apps/nn.js":
/*!********************!*\
  !*** ./apps/nn.js ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! babel-polyfill */ \"../node_modules/babel-polyfill/lib/index.js\");\n\nvar _constants = __webpack_require__(/*! ../game/constants */ \"./game/constants.js\");\n\nvar _game = __webpack_require__(/*! ../game */ \"./game/index.js\");\n\nvar _NNModel = __webpack_require__(/*! ../ai/models/nn/NNModel */ \"./ai/models/nn/NNModel.js\");\n\nvar _NNModel2 = _interopRequireDefault(_NNModel);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar runner = null;\n\nfunction setup() {\n  // Initialize the game Runner.\n  runner = new _game.Runner('.game', {\n    T_REX_COUNT: 1,\n    onReset: handleReset,\n    onCrash: handleCrash,\n    onRunning: handleRunning\n  });\n  // Set runner as a global variable if you need runtime debugging.\n  window.runner = runner;\n  // Initialize everything in the game and start the game.\n  runner.init();\n}\n\nvar firstTime = true;\nfunction handleReset(_ref) {\n  var tRexes = _ref.tRexes;\n\n  var tRex = tRexes[0];\n  if (firstTime) {\n    firstTime = false;\n    tRex.model = new _NNModel2.default();\n    tRex.model.init();\n    tRex.training = {\n      inputs: [],\n      labels: []\n    };\n  } else {\n    // Train the model before restarting.\n    console.info('Training');\n    tRex.model.fit(tRex.training.inputs, tRex.training.labels);\n  }\n}\n\nfunction handleRunning(_ref2) {\n  var tRex = _ref2.tRex,\n      state = _ref2.state;\n\n  return new Promise(function (resolve) {\n    if (!tRex.jumping) {\n      var action = 0;\n      var prediction = tRex.model.predictSingle(convertStateToVector(state));\n      prediction.data().then(function (result) {\n        if (result[1] > result[0]) {\n          action = 1;\n          tRex.lastJumpingState = state;\n        } else {\n          tRex.lastRunningState = state;\n        }\n        resolve(action);\n      });\n    } else {\n      resolve(0);\n    }\n  });\n}\n\nfunction handleCrash(_ref3) {\n  var tRex = _ref3.tRex;\n\n  var input = null;\n  var label = null;\n  if (tRex.jumping) {\n    // Should not jump next time\n    input = convertStateToVector(tRex.lastJumpingState);\n    label = [1, 0];\n  } else {\n    // Should jump next time\n    input = convertStateToVector(tRex.lastRunningState);\n    label = [0, 1];\n  }\n  tRex.training.inputs.push(input);\n  tRex.training.labels.push(label);\n}\n\nfunction convertStateToVector(state) {\n  if (state) {\n    return [state.obstacleX / _constants.CANVAS_WIDTH, state.obstacleWidth / _constants.CANVAS_WIDTH, state.speed / 100];\n  }\n  return [0, 0, 0];\n}\n\ndocument.addEventListener('DOMContentLoaded', setup);\n\n//# sourceURL=webpack:///./apps/nn.js?");

/***/ }),

/***/ "./game/Cloud.js":
/*!***********************!*\
  !*** ./game/Cloud.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _ImageSprite = __webpack_require__(/*! ./ImageSprite */ \"./game/ImageSprite.js\");\n\nvar _utils = __webpack_require__(/*! ./utils */ \"./game/utils.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * Cloud background item.\r\n * Similar to an obstacle object but without collision boxes.\r\n * @param {HTMLCanvasElement} canvas Canvas element.\r\n * @param {Object} spritePos Position of image in sprite.\r\n * @param {number} containerWidth\r\n */\nvar Cloud = function () {\n  function Cloud(canvas, spritePos, containerWidth) {\n    _classCallCheck(this, Cloud);\n\n    this.canvas = canvas;\n    this.canvasCtx = this.canvas.getContext('2d');\n    this.spritePos = spritePos;\n    this.containerWidth = containerWidth;\n    this.xPos = containerWidth;\n    this.yPos = 0;\n    this.remove = false;\n    this.cloudGap = (0, _utils.getRandomNum)(Cloud.config.MIN_CLOUD_GAP, Cloud.config.MAX_CLOUD_GAP);\n\n    this.init();\n  }\n\n  /**\r\n   * Initialise the cloud. Sets the Cloud height.\r\n   */\n\n  /**\r\n   * Cloud object config.\r\n   * @enum {number}\r\n   */\n\n\n  _createClass(Cloud, [{\n    key: 'init',\n    value: function init() {\n      this.yPos = (0, _utils.getRandomNum)(Cloud.config.MAX_SKY_LEVEL, Cloud.config.MIN_SKY_LEVEL);\n      this.draw();\n    }\n\n    /**\r\n     * Draw the cloud.\r\n     */\n\n  }, {\n    key: 'draw',\n    value: function draw() {\n      this.canvasCtx.save();\n      var sourceWidth = Cloud.config.WIDTH;\n      var sourceHeight = Cloud.config.HEIGHT;\n\n      this.canvasCtx.drawImage((0, _ImageSprite.getImageSprite)(), this.spritePos.x, this.spritePos.y, sourceWidth, sourceHeight, this.xPos, this.yPos, Cloud.config.WIDTH, Cloud.config.HEIGHT);\n\n      this.canvasCtx.restore();\n    }\n\n    /**\r\n     * Update the cloud position.\r\n     * @param {number} speed\r\n     */\n\n  }, {\n    key: 'update',\n    value: function update(speed) {\n      if (!this.remove) {\n        this.xPos -= Math.ceil(speed);\n        this.draw();\n\n        // Mark as removeable if no longer in the canvas.\n        if (!this.isVisible()) {\n          this.remove = true;\n        }\n      }\n    }\n\n    /**\r\n     * Check if the cloud is visible on the stage.\r\n     * @return {boolean}\r\n     */\n\n  }, {\n    key: 'isVisible',\n    value: function isVisible() {\n      return this.xPos + Cloud.config.WIDTH > 0;\n    }\n  }]);\n\n  return Cloud;\n}();\n\nCloud.config = {\n  HEIGHT: 14,\n  MAX_CLOUD_GAP: 400,\n  MAX_SKY_LEVEL: 30,\n  MIN_CLOUD_GAP: 100,\n  MIN_SKY_LEVEL: 71,\n  WIDTH: 46\n};\nexports.default = Cloud;\n\n//# sourceURL=webpack:///./game/Cloud.js?");

/***/ }),

/***/ "./game/CollisionBox.js":
/*!******************************!*\
  !*** ./game/CollisionBox.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _constants = __webpack_require__(/*! ./constants */ \"./game/constants.js\");\n\nvar _ImageSprite = __webpack_require__(/*! ./ImageSprite */ \"./game/ImageSprite.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * Collision box object.\r\n * @param {number} x X position.\r\n * @param {number} y Y Position.\r\n * @param {number} w Width.\r\n * @param {number} h Height.\r\n */\nvar CollisionBox = function CollisionBox(x, y, w, h) {\n  _classCallCheck(this, CollisionBox);\n\n  this.x = x;\n  this.y = y;\n  this.width = w;\n  this.height = h;\n};\n\nexports.default = CollisionBox;\n\n//# sourceURL=webpack:///./game/CollisionBox.js?");

/***/ }),

/***/ "./game/DistanceMeter.js":
/*!*******************************!*\
  !*** ./game/DistanceMeter.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _ImageSprite = __webpack_require__(/*! ./ImageSprite */ \"./game/ImageSprite.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * Handles displaying the distance meter.\r\n * @param {!HTMLCanvasElement} canvas\r\n * @param {Object} spritePos Image position in sprite.\r\n * @param {number} canvasWidth\r\n * @constructor\r\n */\nvar DistanceMeter = function () {\n  function DistanceMeter(canvas, spritePos, canvasWidth) {\n    _classCallCheck(this, DistanceMeter);\n\n    this.canvas = canvas;\n    this.canvasCtx = canvas.getContext('2d');\n    this.image = (0, _ImageSprite.getImageSprite)();\n    this.spritePos = spritePos;\n    this.x = 0;\n    this.y = 5;\n\n    this.currentDistance = 0;\n    this.maxScore = 0;\n    this.highScore = 0;\n    this.container = null;\n\n    this.digits = [];\n    this.acheivement = false;\n    this.defaultString = '';\n    this.flashTimer = 0;\n    this.flashIterations = 0;\n    this.invertTrigger = false;\n\n    this.config = DistanceMeter.config;\n    this.maxScoreUnits = this.config.MAX_DISTANCE_UNITS;\n    this.init(canvasWidth);\n  }\n\n  /**\r\n   * Initialise the distance meter to '00000'.\r\n   * @param {number} width Canvas width in px.\r\n   */\n\n\n  _createClass(DistanceMeter, [{\n    key: 'init',\n    value: function init(width) {\n      var maxDistanceStr = '';\n\n      this.calcXPos(width);\n      this.maxScore = this.maxScoreUnits;\n      for (var i = 0; i < this.maxScoreUnits; i += 1) {\n        this.draw(i, 0);\n        this.defaultString += '0';\n        maxDistanceStr += '9';\n      }\n\n      this.maxScore = parseInt(maxDistanceStr, 0);\n    }\n\n    /**\r\n     * Calculate the xPos in the canvas.\r\n     * @param {number} canvasWidth\r\n     */\n\n  }, {\n    key: 'calcXPos',\n    value: function calcXPos(canvasWidth) {\n      this.x = canvasWidth - DistanceMeter.dimensions.DEST_WIDTH * (this.maxScoreUnits + 1);\n    }\n\n    /**\r\n     * Draw a digit to canvas.\r\n     * @param {number} digitPos Position of the digit.\r\n     * @param {number} value Digit value 0-9.\r\n     * @param {boolean} highScore Whether drawing the high score.\r\n     */\n\n  }, {\n    key: 'draw',\n    value: function draw(digitPos, value, highScore) {\n      var sourceWidth = DistanceMeter.dimensions.WIDTH;\n      var sourceHeight = DistanceMeter.dimensions.HEIGHT;\n      var sourceX = DistanceMeter.dimensions.WIDTH * value;\n      var sourceY = 0;\n\n      var targetX = digitPos * DistanceMeter.dimensions.DEST_WIDTH;\n      var targetY = this.y;\n      var targetWidth = DistanceMeter.dimensions.WIDTH;\n      var targetHeight = DistanceMeter.dimensions.HEIGHT;\n\n      sourceX += this.spritePos.x;\n      sourceY += this.spritePos.y;\n\n      this.canvasCtx.save();\n\n      if (highScore) {\n        // Left of the current score.\n        var highScoreX = this.x - this.maxScoreUnits * 2 * DistanceMeter.dimensions.WIDTH;\n        this.canvasCtx.translate(highScoreX, this.y);\n      } else {\n        this.canvasCtx.translate(this.x, this.y);\n      }\n\n      this.canvasCtx.drawImage(this.image, sourceX, sourceY, sourceWidth, sourceHeight, targetX, targetY, targetWidth, targetHeight);\n\n      this.canvasCtx.restore();\n    }\n\n    /**\r\n     * Covert pixel distance to a 'real' distance.\r\n     * @param {number} distance Pixel distance ran.\r\n     * @return {number} The 'real' distance ran.\r\n     */\n\n  }, {\n    key: 'getActualDistance',\n    value: function getActualDistance(distance) {\n      return distance ? Math.round(distance * this.config.COEFFICIENT) : 0;\n    }\n\n    /**\r\n     * Update the distance meter.\r\n     * @param {number} distance\r\n     * @param {number} deltaTime\r\n     */\n\n  }, {\n    key: 'update',\n    value: function update(deltaTime, distance) {\n      var paint = true;\n\n      if (!this.acheivement) {\n        distance = this.getActualDistance(distance);\n        // Score has gone beyond the initial digit count.\n        if (distance > this.maxScore && this.maxScoreUnits === this.config.MAX_DISTANCE_UNITS) {\n          this.maxScoreUnits += 1;\n          this.maxScore = parseInt(this.maxScore + '9', 1);\n        } else {\n          this.distance = 0;\n        }\n\n        if (distance > 0) {\n          // Acheivement unlocked\n          if (distance % this.config.ACHIEVEMENT_DISTANCE === 0) {\n            this.acheivement = true;\n            this.flashTimer = 0;\n          }\n\n          // Create a string representation of the distance with leading 0.\n          var distanceStr = (this.defaultString + distance).substr(-this.maxScoreUnits);\n          this.digits = distanceStr.split('');\n        } else {\n          this.digits = this.defaultString.split('');\n        }\n      } else if (this.flashIterations <= this.config.FLASH_ITERATIONS) {\n        this.flashTimer += deltaTime;\n\n        if (this.flashTimer < this.config.FLASH_DURATION) {\n          paint = false;\n        } else if (this.flashTimer > this.config.FLASH_DURATION * 2) {\n          this.flashTimer = 0;\n          this.flashIterations += 1;\n        }\n      } else {\n        this.acheivement = false;\n        this.flashIterations = 0;\n        this.flashTimer = 0;\n      }\n\n      // Draw the digits if not flashing.\n      if (paint) {\n        for (var i = this.digits.length - 1; i >= 0; i -= 1) {\n          this.draw(i, parseInt(this.digits[i], 0));\n        }\n      }\n\n      this.drawHighScore();\n    }\n    /**\r\n     * Draw the high score.\r\n     */\n\n  }, {\n    key: 'drawHighScore',\n    value: function drawHighScore() {\n      this.canvasCtx.save();\n      this.canvasCtx.globalAlpha = 0.8;\n      for (var i = this.highScore.length - 1; i >= 0; i -= 1) {\n        this.draw(i, parseInt(this.highScore[i], 10), true);\n      }\n      this.canvasCtx.restore();\n    }\n\n    /**\r\n     * Set the highscore as a array string.\r\n     * Position of char in the sprite: H - 10, I - 11.\r\n     * @param {number} distance Distance ran in pixels.\r\n     */\n\n  }, {\n    key: 'setHighScore',\n    value: function setHighScore(distance) {\n      distance = this.getActualDistance(distance);\n      var highScoreStr = (this.defaultString + distance).substr(-this.maxScoreUnits);\n\n      this.highScore = ['10', '11', ''].concat(highScoreStr.split(''));\n    }\n\n    /**\r\n     * Reset the distance meter back to '00000'.\r\n     */\n\n  }, {\n    key: 'reset',\n    value: function reset() {\n      this.update(0);\n      this.acheivement = false;\n    }\n  }]);\n\n  return DistanceMeter;\n}();\n\nDistanceMeter.dimensions = {\n  WIDTH: 10,\n  HEIGHT: 13,\n  DEST_WIDTH: 11\n};\nDistanceMeter.yPos = [0, 13, 27, 40, 53, 67, 80, 93, 107, 120];\nDistanceMeter.config = {\n  // Number of digits.\n  MAX_DISTANCE_UNITS: 5,\n\n  // Distance that causes achievement animation.\n  ACHIEVEMENT_DISTANCE: 100,\n\n  // Used for conversion from pixel distance to a scaled unit.\n  COEFFICIENT: 0.025,\n\n  // Flash duration in milliseconds.\n  FLASH_DURATION: 1000 / 4,\n\n  // Flash iterations for achievement animation.\n  FLASH_ITERATIONS: 3\n};\nexports.default = DistanceMeter;\n\n//# sourceURL=webpack:///./game/DistanceMeter.js?");

/***/ }),

/***/ "./game/Horizon.js":
/*!*************************!*\
  !*** ./game/Horizon.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _utils = __webpack_require__(/*! ./utils */ \"./game/utils.js\");\n\nvar _constants = __webpack_require__(/*! ./constants */ \"./game/constants.js\");\n\nvar _Cloud = __webpack_require__(/*! ./Cloud */ \"./game/Cloud.js\");\n\nvar _Cloud2 = _interopRequireDefault(_Cloud);\n\nvar _HorizonLine = __webpack_require__(/*! ./HorizonLine */ \"./game/HorizonLine.js\");\n\nvar _HorizonLine2 = _interopRequireDefault(_HorizonLine);\n\nvar _Obstacle = __webpack_require__(/*! ./Obstacle */ \"./game/Obstacle.js\");\n\nvar _Obstacle2 = _interopRequireDefault(_Obstacle);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * Horizon background class.\r\n * @param {HTMLCanvasElement} canvas\r\n * @param {Object} spritePos Sprite positioning.\r\n * @param {Object} dimensions Canvas dimensions.\r\n * @param {number} gapCoefficient\r\n * @constructor\r\n */\nvar Horizon = function () {\n  function Horizon(canvas, spritePos, dimensions, gapCoefficient) {\n    _classCallCheck(this, Horizon);\n\n    this.canvas = canvas;\n    this.canvasCtx = this.canvas.getContext('2d');\n    this.config = Horizon.config;\n    this.dimensions = dimensions;\n    this.gapCoefficient = gapCoefficient;\n    this.obstacles = [];\n    this.obstacleHistory = [];\n    this.horizonOffsets = [0, 0];\n    this.cloudFrequency = this.config.CLOUD_FREQUENCY;\n    this.spritePos = spritePos;\n\n    // Cloud\n    this.clouds = [];\n    this.cloudSpeed = this.config.BG_CLOUD_SPEED;\n\n    // Horizon\n    this.horizonLine = null;\n    this.init();\n  }\n\n  /**\r\n   * Initialise the horizon. Just add the line and a cloud. No obstacles.\r\n   */\n\n  /**\r\n   * Horizon config.\r\n   * @enum {number}\r\n   */\n\n\n  _createClass(Horizon, [{\n    key: 'init',\n    value: function init() {\n      this.addCloud();\n      this.horizonLine = new _HorizonLine2.default(this.canvas, this.spritePos.HORIZON);\n    }\n\n    /**\r\n     * @param {number} deltaTime\r\n     * @param {number} currentSpeed\r\n     * @param {boolean} updateObstacles Used as an override to prevent\r\n     *     the obstacles from being updated / added. This happens in the\r\n     *     ease in section.\r\n     */\n\n  }, {\n    key: 'update',\n    value: function update(deltaTime, currentSpeed, updateObstacles) {\n      this.runningTime += deltaTime;\n      this.horizonLine.update(deltaTime, currentSpeed);\n      this.updateClouds(deltaTime, currentSpeed);\n\n      if (updateObstacles) {\n        this.updateObstacles(deltaTime, currentSpeed);\n      }\n    }\n\n    /**\r\n     * Update the cloud positions.\r\n     * @param {number} deltaTime\r\n     * @param {number} currentSpeed\r\n     */\n\n  }, {\n    key: 'updateClouds',\n    value: function updateClouds(deltaTime, speed) {\n      var cloudSpeed = this.cloudSpeed / 1000 * deltaTime * speed;\n      var numClouds = this.clouds.length;\n\n      if (numClouds) {\n        for (var i = numClouds - 1; i >= 0; i -= 1) {\n          this.clouds[i].update(cloudSpeed);\n        }\n\n        var lastCloud = this.clouds[numClouds - 1];\n\n        // Check for adding a new cloud.\n        if (numClouds < this.config.MAX_CLOUDS && this.dimensions.WIDTH - lastCloud.xPos > lastCloud.cloudGap && this.cloudFrequency > Math.random()) {\n          this.addCloud();\n        }\n\n        // Remove expired clouds.\n        this.clouds = this.clouds.filter(function (obj) {\n          return !obj.remove;\n        });\n      } else {\n        this.addCloud();\n      }\n    }\n\n    /**\r\n     * Update the obstacle positions.\r\n     * @param {number} deltaTime\r\n     * @param {number} currentSpeed\r\n     */\n\n  }, {\n    key: 'updateObstacles',\n    value: function updateObstacles(deltaTime, currentSpeed) {\n      // Obstacles, move to Horizon layer.\n      var updatedObstacles = this.obstacles.slice(0);\n\n      for (var i = 0; i < this.obstacles.length; i += 1) {\n        var obstacle = this.obstacles[i];\n        obstacle.update(deltaTime, currentSpeed);\n\n        // Clean up existing obstacles.\n        if (obstacle.remove) {\n          updatedObstacles.shift();\n        }\n      }\n      this.obstacles = updatedObstacles;\n\n      if (this.obstacles.length > 0) {\n        var lastObstacle = this.obstacles[this.obstacles.length - 1];\n\n        if (lastObstacle && !lastObstacle.followingObstacleCreated && lastObstacle.isVisible() && lastObstacle.xPos + lastObstacle.width + lastObstacle.gap < this.dimensions.WIDTH) {\n          this.addNewObstacle(currentSpeed);\n          lastObstacle.followingObstacleCreated = true;\n        }\n      } else {\n        // Create new obstacles.\n        this.addNewObstacle(currentSpeed);\n      }\n    }\n  }, {\n    key: 'removeFirstObstacle',\n    value: function removeFirstObstacle() {\n      this.obstacles.shift();\n    }\n\n    /**\r\n     * Add a new obstacle.\r\n     * @param {number} currentSpeed\r\n     */\n\n  }, {\n    key: 'addNewObstacle',\n    value: function addNewObstacle(currentSpeed) {\n      var obstacleTypeIndex = (0, _utils.getRandomNum)(0, _Obstacle2.default.types.length - 1);\n      var obstacleType = _Obstacle2.default.types[obstacleTypeIndex];\n\n      // Check for multiples of the same type of obstacle.\n      // Also check obstacle is available at current speed.\n      if (this.duplicateObstacleCheck(obstacleType.type) || currentSpeed < obstacleType.minSpeed) {\n        this.addNewObstacle(currentSpeed);\n      } else {\n        var obstacleSpritePos = this.spritePos[obstacleType.type];\n\n        this.obstacles.push(new _Obstacle2.default(this.canvasCtx, obstacleType, obstacleSpritePos, this.dimensions, this.gapCoefficient, currentSpeed, obstacleType.width));\n\n        this.obstacleHistory.unshift(obstacleType.type);\n\n        if (this.obstacleHistory.length > 1) {\n          this.obstacleHistory.splice(_constants.RUNNER_MAX_OBSTACLE_DUPLICATION);\n        }\n      }\n    }\n\n    /**\r\n     * Returns whether the previous two obstacles are the same as the next one.\r\n     * Maximum duplication is set in config value MAX_OBSTACLE_DUPLICATION.\r\n     * @return {boolean}\r\n     */\n\n  }, {\n    key: 'duplicateObstacleCheck',\n    value: function duplicateObstacleCheck(nextObstacleType) {\n      var duplicateCount = 0;\n\n      for (var i = 0; i < this.obstacleHistory.length; i += 1) {\n        duplicateCount = this.obstacleHistory[i] === nextObstacleType ? duplicateCount + 1 : 0;\n      }\n      return duplicateCount >= _constants.RUNNER_MAX_OBSTACLE_DUPLICATION;\n    }\n\n    /**\r\n     * Reset the horizon layer.\r\n     * Remove existing obstacles and reposition the horizon line.\r\n     */\n\n  }, {\n    key: 'reset',\n    value: function reset() {\n      this.obstacles = [];\n      this.horizonLine.reset();\n    }\n\n    /**\r\n     * Update the canvas width and scaling.\r\n     * @param {number} width Canvas width.\r\n     * @param {number} height Canvas height.\r\n     */\n\n  }, {\n    key: 'resize',\n    value: function resize(width, height) {\n      this.canvas.width = width;\n      this.canvas.height = height;\n    }\n\n    /**\r\n     * Add a new cloud to the horizon.\r\n     */\n\n  }, {\n    key: 'addCloud',\n    value: function addCloud() {\n      this.clouds.push(new _Cloud2.default(this.canvas, this.spritePos.CLOUD, this.dimensions.WIDTH));\n    }\n  }]);\n\n  return Horizon;\n}();\n\nHorizon.config = {\n  BG_CLOUD_SPEED: 0.2,\n  BUMPY_THRESHOLD: 0.3,\n  CLOUD_FREQUENCY: 0.5,\n  HORIZON_HEIGHT: 16,\n  MAX_CLOUDS: 6\n};\nexports.default = Horizon;\n\n//# sourceURL=webpack:///./game/Horizon.js?");

/***/ }),

/***/ "./game/HorizonLine.js":
/*!*****************************!*\
  !*** ./game/HorizonLine.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _RuntimeConfig = __webpack_require__(/*! ./RuntimeConfig */ \"./game/RuntimeConfig.js\");\n\nvar _ImageSprite = __webpack_require__(/*! ./ImageSprite */ \"./game/ImageSprite.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * Horizon Line.\r\n * Consists of two connecting lines. Randomly assigns a flat / bumpy horizon.\r\n * @param {HTMLCanvasElement} canvas\r\n * @param {Object} spritePos Horizon position in sprite.\r\n * @constructor\r\n */\nvar HorizonLine = function () {\n  function HorizonLine(canvas, spritePos) {\n    _classCallCheck(this, HorizonLine);\n\n    this.spritePos = spritePos;\n    this.canvas = canvas;\n    this.canvasCtx = canvas.getContext('2d');\n    this.sourceDimensions = {};\n    this.dimensions = HorizonLine.dimensions;\n    this.sourceXPos = [this.spritePos.x, this.spritePos.x + this.dimensions.WIDTH];\n    this.xPos = [];\n    this.yPos = 0;\n    this.bumpThreshold = 0.5;\n\n    this.setSourceDimensions();\n    this.draw();\n  }\n\n  /**\r\n   * Set the source dimensions of the horizon line.\r\n   */\n\n  /**\r\n   * Horizon line dimensions.\r\n   * @enum {number}\r\n   */\n\n\n  _createClass(HorizonLine, [{\n    key: 'setSourceDimensions',\n    value: function setSourceDimensions() {\n      /* eslint-disable-next-line */\n      for (var dimension in HorizonLine.dimensions) {\n        this.sourceDimensions[dimension] = HorizonLine.dimensions[dimension];\n        this.dimensions[dimension] = HorizonLine.dimensions[dimension];\n      }\n\n      this.xPos = [0, HorizonLine.dimensions.WIDTH];\n      this.yPos = HorizonLine.dimensions.YPOS;\n    }\n\n    /**\r\n     * Return the crop x position of a type.\r\n     */\n\n  }, {\n    key: 'getRandomType',\n    value: function getRandomType() {\n      return Math.random() > this.bumpThreshold ? this.dimensions.WIDTH : 0;\n    }\n\n    /**\r\n     * Draw the horizon line.\r\n     */\n\n  }, {\n    key: 'draw',\n    value: function draw() {\n      this.canvasCtx.drawImage((0, _ImageSprite.getImageSprite)(), this.sourceXPos[0], this.spritePos.y, this.sourceDimensions.WIDTH, this.sourceDimensions.HEIGHT, this.xPos[0], this.yPos, this.dimensions.WIDTH, this.dimensions.HEIGHT);\n\n      this.canvasCtx.drawImage((0, _ImageSprite.getImageSprite)(), this.sourceXPos[1], this.spritePos.y, this.sourceDimensions.WIDTH, this.sourceDimensions.HEIGHT, this.xPos[1], this.yPos, this.dimensions.WIDTH, this.dimensions.HEIGHT);\n    }\n\n    /**\r\n     * Update the x position of an indivdual piece of the line.\r\n     * @param {number} pos Line position.\r\n     * @param {number} increment\r\n     */\n\n  }, {\n    key: 'updateXPos',\n    value: function updateXPos(pos, increment) {\n      var line1 = pos;\n      var line2 = pos === 0 ? 1 : 0;\n\n      this.xPos[line1] -= increment;\n      this.xPos[line2] = this.xPos[line1] + this.dimensions.WIDTH;\n\n      if (this.xPos[line1] <= -this.dimensions.WIDTH) {\n        this.xPos[line1] += this.dimensions.WIDTH * 2;\n        this.xPos[line2] = this.xPos[line1] - this.dimensions.WIDTH;\n        this.sourceXPos[line1] = this.getRandomType() + this.spritePos.x;\n      }\n    }\n\n    /**\r\n     * Update the horizon line.\r\n     * @param {number} deltaTime\r\n     * @param {number} speed\r\n     */\n\n  }, {\n    key: 'update',\n    value: function update(deltaTime, speed) {\n      var increment = Math.floor(speed * ((0, _RuntimeConfig.getFPS)() / 1000) * deltaTime);\n\n      if (this.xPos[0] <= 0) {\n        this.updateXPos(0, increment);\n      } else {\n        this.updateXPos(1, increment);\n      }\n      this.draw();\n    }\n\n    /**\r\n     * Reset horizon to the starting position.\r\n     */\n\n  }, {\n    key: 'reset',\n    value: function reset() {\n      this.xPos[0] = 0;\n      this.xPos[1] = HorizonLine.dimensions.WIDTH;\n    }\n  }]);\n\n  return HorizonLine;\n}();\n\nHorizonLine.dimensions = {\n  WIDTH: 600,\n  HEIGHT: 12,\n  YPOS: 127\n};\nexports.default = HorizonLine;\n\n//# sourceURL=webpack:///./game/HorizonLine.js?");

/***/ }),

/***/ "./game/ImageSprite.js":
/*!*****************************!*\
  !*** ./game/ImageSprite.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getImageSprite = getImageSprite;\nexports.loadImageSprite = loadImageSprite;\nvar _imageSprite = null;\n\nfunction getImageSprite() {\n  return _imageSprite;\n}\n\nfunction loadImageSprite() {\n  return new Promise(function (resolve) {\n    var imageSprite = document.createElement('img');\n    imageSprite.src = __webpack_require__(/*! ./images/offline-sprite.png */ \"./game/images/offline-sprite.png\");\n    imageSprite.addEventListener('load', function () {\n      _imageSprite = imageSprite;\n      resolve();\n    });\n  });\n}\n\n//# sourceURL=webpack:///./game/ImageSprite.js?");

/***/ }),

/***/ "./game/Obstacle.js":
/*!**************************!*\
  !*** ./game/Obstacle.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _RuntimeConfig = __webpack_require__(/*! ./RuntimeConfig */ \"./game/RuntimeConfig.js\");\n\nvar _ImageSprite = __webpack_require__(/*! ./ImageSprite */ \"./game/ImageSprite.js\");\n\nvar _utils = __webpack_require__(/*! ./utils */ \"./game/utils.js\");\n\nvar _CollisionBox = __webpack_require__(/*! ./CollisionBox */ \"./game/CollisionBox.js\");\n\nvar _CollisionBox2 = _interopRequireDefault(_CollisionBox);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * Obstacle.\r\n * @param {HTMLCanvasCtx} canvasCtx\r\n * @param {Obstacle.type} type\r\n * @param {Object} spritePos Obstacle position in sprite.\r\n * @param {Object} dimensions\r\n * @param {number} gapCoefficient Mutipler in determining the gap.\r\n * @param {number} speed\r\n * @param {number} offset\r\n */\nvar Obstacle = function () {\n\n  /**\r\n   * Maximum obstacle grouping count.\r\n   * @const\r\n   */\n  function Obstacle(canvasCtx, type, spriteImgPos, dimensions, gapCoefficient, speed, offset) {\n    _classCallCheck(this, Obstacle);\n\n    this.canvasCtx = canvasCtx;\n    this.spritePos = spriteImgPos;\n    this.typeConfig = type;\n    this.gapCoefficient = gapCoefficient;\n    this.size = (0, _utils.getRandomNum)(1, Obstacle.MAX_OBSTACLE_LENGTH);\n    this.dimensions = dimensions;\n    this.remove = false;\n    this.xPos = dimensions.WIDTH + (offset || 0);\n    this.yPos = 0;\n    this.width = 0;\n    this.collisionBoxes = [];\n    this.gap = 0;\n    this.speedOffset = 0;\n\n    // For animated obstacles.\n    this.currentFrame = 0;\n    this.timer = 0;\n\n    this.init(speed);\n  }\n  /**\r\n   * Coefficient for calculating the maximum gap.\r\n   * @const\r\n   */\n\n\n  _createClass(Obstacle, [{\n    key: 'init',\n    value: function init(speed) {\n      this.cloneCollisionBoxes();\n\n      // Only allow sizing if we're at the right speed.\n      if (this.size > 1 && this.typeConfig.multipleSpeed > speed) {\n        this.size = 1;\n      }\n\n      this.width = this.typeConfig.width * this.size;\n\n      // Check if obstacle can be positioned at various heights.\n      if (Array.isArray(this.typeConfig.yPos)) {\n        var yPosConfig = this.typeConfig.yPos;\n        this.yPos = yPosConfig[(0, _utils.getRandomNum)(0, yPosConfig.length - 1)];\n      } else {\n        this.yPos = this.typeConfig.yPos;\n      }\n\n      this.draw();\n\n      // Make collision box adjustments,\n      // Central box is adjusted to the size as one box.\n      //      ____        ______        ________\n      //    _|   |-|    _|     |-|    _|       |-|\n      //   | |<->| |   | |<--->| |   | |<----->| |\n      //   | | 1 | |   | |  2  | |   | |   3   | |\n      //   |_|___|_|   |_|_____|_|   |_|_______|_|\n      //\n      if (this.size > 1) {\n        this.collisionBoxes[1].width = this.width - this.collisionBoxes[0].width - this.collisionBoxes[2].width;\n        this.collisionBoxes[2].x = this.width - this.collisionBoxes[2].width;\n      }\n\n      // For obstacles that go at a different speed from the horizon.\n      if (this.typeConfig.speedOffset) {\n        this.speedOffset = Math.random() > 0.5 ? this.typeConfig.speedOffset : -this.typeConfig.speedOffset;\n      }\n\n      this.gap = this.getGap(this.gapCoefficient, speed);\n    }\n\n    /**\r\n     * Draw and crop based on size.\r\n     */\n\n  }, {\n    key: 'draw',\n    value: function draw() {\n      var sourceWidth = this.typeConfig.width;\n      var sourceHeight = this.typeConfig.height;\n\n      // X position in sprite.\n      var sourceX = sourceWidth * this.size * (0.5 * (this.size - 1)) + this.spritePos.x;\n\n      // Animation frames.\n      if (this.currentFrame > 0) {\n        sourceX += sourceWidth * this.currentFrame;\n      }\n\n      this.canvasCtx.drawImage((0, _ImageSprite.getImageSprite)(), sourceX, this.spritePos.y, sourceWidth * this.size, sourceHeight, this.xPos, this.yPos, this.typeConfig.width * this.size, this.typeConfig.height);\n    }\n\n    /**\r\n     * Obstacle frame update.\r\n     * @param {number} deltaTime\r\n     * @param {number} speed\r\n     */\n\n  }, {\n    key: 'update',\n    value: function update(deltaTime, speed) {\n      if (!this.remove) {\n        if (this.typeConfig.speedOffset) {\n          speed += this.speedOffset;\n        }\n        this.xPos -= Math.floor(speed * (0, _RuntimeConfig.getFPS)() / 1000 * deltaTime);\n\n        // Update frame\n        if (this.typeConfig.numFrames) {\n          this.timer += deltaTime;\n          if (this.timer >= this.typeConfig.frameRate) {\n            this.currentFrame = this.currentFrame === this.typeConfig.numFrames - 1 ? 0 : this.currentFrame + 1;\n            this.timer = 0;\n          }\n        }\n        this.draw();\n\n        if (!this.isVisible()) {\n          this.remove = true;\n        }\n      }\n    }\n\n    /**\r\n     * Calculate a random gap size.\r\n     * - Minimum gap gets wider as speed increses\r\n     * @param {number} gapCoefficient\r\n     * @param {number} speed\r\n     * @return {number} The gap size.\r\n     */\n\n  }, {\n    key: 'getGap',\n    value: function getGap(gapCoefficient, speed) {\n      var minGap = Math.round(this.width * speed + this.typeConfig.minGap * gapCoefficient);\n      var maxGap = Math.round(minGap * Obstacle.MAX_GAP_COEFFICIENT);\n      return (0, _utils.getRandomNum)(minGap, maxGap);\n    }\n\n    /**\r\n     * Check if obstacle is visible.\r\n     * @return {boolean} Whether the obstacle is in the game area.\r\n     */\n\n  }, {\n    key: 'isVisible',\n    value: function isVisible() {\n      return this.xPos + this.width > 0;\n    }\n\n    /**\r\n     * Make a copy of the collision boxes, since these will change based on\r\n     * obstacle type and size.\r\n     */\n\n  }, {\n    key: 'cloneCollisionBoxes',\n    value: function cloneCollisionBoxes() {\n      var collisionBoxes = this.typeConfig.collisionBoxes;\n\n\n      for (var i = collisionBoxes.length - 1; i >= 0; i -= 1) {\n        this.collisionBoxes[i] = new _CollisionBox2.default(collisionBoxes[i].x, collisionBoxes[i].y, collisionBoxes[i].width, collisionBoxes[i].height);\n      }\n    }\n  }]);\n\n  return Obstacle;\n}();\n\nObstacle.MAX_GAP_COEFFICIENT = 1.5;\nObstacle.MAX_OBSTACLE_LENGTH = 3;\nObstacle.types = [{\n  type: 'CACTUS_SMALL',\n  width: 17,\n  height: 35,\n  yPos: 105,\n  multipleSpeed: 4,\n  minGap: 120,\n  minSpeed: 0,\n  collisionBoxes: [new _CollisionBox2.default(0, 7, 5, 27), new _CollisionBox2.default(4, 0, 6, 34), new _CollisionBox2.default(10, 4, 7, 14)]\n}, {\n  type: 'CACTUS_LARGE',\n  width: 25,\n  height: 50,\n  yPos: 90,\n  multipleSpeed: 7,\n  minGap: 120,\n  minSpeed: 0,\n  collisionBoxes: [new _CollisionBox2.default(0, 12, 7, 38), new _CollisionBox2.default(8, 0, 7, 49), new _CollisionBox2.default(13, 10, 10, 38)]\n}, {\n  type: 'PTERODACTYL',\n  width: 46,\n  height: 40,\n  yPos: [100, 75, 50], // Variable height.\n  yPosMobile: [100, 50], // Variable height mobile.\n  multipleSpeed: 999,\n  minSpeed: 8.5,\n  minGap: 150,\n  collisionBoxes: [new _CollisionBox2.default(15, 15, 16, 5), new _CollisionBox2.default(18, 21, 24, 6), new _CollisionBox2.default(2, 14, 4, 3), new _CollisionBox2.default(6, 10, 4, 7), new _CollisionBox2.default(10, 8, 6, 9)],\n  numFrames: 2,\n  frameRate: 1000 / 6,\n  speedOffset: 0.8\n}];\nexports.default = Obstacle;\n\n//# sourceURL=webpack:///./game/Obstacle.js?");

/***/ }),

/***/ "./game/Runner.js":
/*!************************!*\
  !*** ./game/Runner.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _constants = __webpack_require__(/*! ./constants */ \"./game/constants.js\");\n\nvar _RuntimeConfig = __webpack_require__(/*! ./RuntimeConfig */ \"./game/RuntimeConfig.js\");\n\nvar _ImageSprite = __webpack_require__(/*! ./ImageSprite */ \"./game/ImageSprite.js\");\n\nvar _utils = __webpack_require__(/*! ./utils */ \"./game/utils.js\");\n\nvar _DistanceMeter = __webpack_require__(/*! ./DistanceMeter */ \"./game/DistanceMeter.js\");\n\nvar _DistanceMeter2 = _interopRequireDefault(_DistanceMeter);\n\nvar _Horizon = __webpack_require__(/*! ./Horizon */ \"./game/Horizon.js\");\n\nvar _Horizon2 = _interopRequireDefault(_Horizon);\n\nvar _Trex = __webpack_require__(/*! ./Trex */ \"./game/Trex.js\");\n\nvar _Trex2 = _interopRequireDefault(_Trex);\n\nvar _TrexGroup = __webpack_require__(/*! ./TrexGroup */ \"./game/TrexGroup.js\");\n\nvar _TrexGroup2 = _interopRequireDefault(_TrexGroup);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * T-Rex runner.\r\n * @param {string} outerContainerId Outer containing element id.\r\n * @param {Object} options\r\n * @constructor\r\n * @export\r\n */\nvar Runner = function () {\n\n  /**\r\n   * Key code mapping.\r\n   * @enum {Object}\r\n   */\n  function Runner(outerContainerId, options) {\n    _classCallCheck(this, Runner);\n\n    // Singleton\n    if (Runner.instance_) {\n      return Runner.instance_;\n    }\n    Runner.instance_ = this;\n\n    this.isFirstTime = false;\n    this.outerContainerEl = document.querySelector(outerContainerId);\n    this.generationEl = document.querySelector('.generation');\n    this.containerEl = null;\n\n    this.config = Object.assign({}, Runner.config, options);\n\n    this.dimensions = {\n      WIDTH: _constants.CANVAS_WIDTH,\n      HEIGHT: _constants.CANVAS_HEIGHT\n    };\n\n    this.canvas = null;\n    this.canvasCtx = null;\n\n    this.tRex = null;\n\n    this.distanceMeter = null;\n    this.distanceRan = 0;\n\n    this.highestScore = 0;\n\n    this.time = 0;\n    this.runningTime = 0;\n    this.msPerFrame = 1000 / (0, _RuntimeConfig.getFPS)();\n    this.currentSpeed = this.config.SPEED;\n\n    this.obstacles = [];\n\n    this.activated = false; // Whether the easter egg has been activated.\n    this.playing = false; // Whether the game is currently in play state.\n    this.crashed = false;\n    this.resizeTimerId_ = null;\n\n    this.playCount = 0;\n\n    // Images.\n    this.images = {};\n    this.imagesLoaded = 0;\n  }\n\n  /**\r\n   * Runner event names.\r\n   * @enum {string}\r\n   */\n\n\n  _createClass(Runner, [{\n    key: 'init',\n    value: function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return (0, _ImageSprite.loadImageSprite)();\n\n              case 2:\n                this.spriteDef = Runner.spriteDefinition;\n\n                this.adjustDimensions();\n                this.setSpeed();\n\n                this.containerEl = document.createElement('div');\n                this.containerEl.className = Runner.classes.CONTAINER;\n                this.containerEl.style.width = this.dimensions.WIDTH + 'px';\n\n                // Player canvas container.\n                this.canvas = createCanvas(this.containerEl, this.dimensions.WIDTH, this.dimensions.HEIGHT, Runner.classes.PLAYER);\n\n                this.canvasCtx = this.canvas.getContext('2d');\n                this.canvasCtx.fillStyle = '#f7f7f7';\n                this.canvasCtx.fill();\n                Runner.updateCanvasScaling(this.canvas);\n\n                // Horizon contains clouds, obstacles and the ground.\n                this.horizon = new _Horizon2.default(this.canvas, this.spriteDef, this.dimensions, this.config.GAP_COEFFICIENT);\n\n                // Distance meter\n                this.distanceMeter = new _DistanceMeter2.default(this.canvas, this.spriteDef.TEXT_SPRITE, this.dimensions.WIDTH);\n\n                // Draw t-rex\n                this.tRexGroup = new _TrexGroup2.default(this.config.T_REX_COUNT, this.canvas, this.spriteDef.TREX);\n                this.tRexGroup.onRunning = this.config.onRunning;\n                this.tRexGroup.onCrash = this.config.onCrash;\n                this.tRex = this.tRexGroup.tRexes[0];\n\n                this.outerContainerEl.appendChild(this.containerEl);\n\n                this.startListening();\n                this.update();\n\n                window.addEventListener(Runner.events.RESIZE, this.debounceResize.bind(this));\n\n                this.restart();\n\n              case 24:\n              case 'end':\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function init() {\n        return _ref.apply(this, arguments);\n      }\n\n      return init;\n    }()\n\n    /**\r\n     * Debounce the resize event.\r\n     */\n\n  }, {\n    key: 'debounceResize',\n    value: function debounceResize() {\n      if (!this.resizeTimerId_) {\n        this.resizeTimerId_ = setInterval(this.adjustDimensions.bind(this), 250);\n      }\n    }\n\n    /**\r\n     * Adjust game space dimensions on resize.\r\n     */\n\n  }, {\n    key: 'adjustDimensions',\n    value: function adjustDimensions() {\n      clearInterval(this.resizeTimerId_);\n      this.resizeTimerId_ = null;\n\n      var boxStyles = window.getComputedStyle(this.outerContainerEl);\n      var padding = Number(boxStyles.paddingLeft.substr(0, boxStyles.paddingLeft.length - 2));\n\n      this.dimensions.WIDTH = this.outerContainerEl.offsetWidth - padding * 2;\n\n      // Redraw the elements back onto the canvas.\n      if (this.canvas) {\n        this.canvas.width = this.dimensions.WIDTH;\n        this.canvas.height = this.dimensions.HEIGHT;\n\n        Runner.updateCanvasScaling(this.canvas);\n\n        this.distanceMeter.calcXPos(this.dimensions.WIDTH);\n        this.clearCanvas();\n        this.horizon.update(0, 0, true);\n        this.tRexGroup.update(0);\n\n        // Outer container and distance meter.\n        if (this.playing || this.crashed) {\n          this.containerEl.style.width = this.dimensions.WIDTH + 'px';\n          this.containerEl.style.height = this.dimensions.HEIGHT + 'px';\n          this.distanceMeter.update(0, Math.ceil(this.distanceRan));\n          this.stop();\n        } else {\n          this.tRexGroup.draw(0, 0);\n        }\n      }\n    }\n\n    /**\r\n     * Sets the game speed. Adjust the speed accordingly if on a smaller screen.\r\n     * @param {number} speed\r\n     */\n\n  }, {\n    key: 'setSpeed',\n    value: function setSpeed(speed) {\n      this.currentSpeed = speed || this.currentSpeed;\n    }\n\n    /**\r\n     * Update the game status to started.\r\n     */\n\n  }, {\n    key: 'startGame',\n    value: function startGame() {\n      this.runningTime = 0;\n      this.containerEl.style.webkitAnimation = '';\n      this.playCount += 1;\n    }\n  }, {\n    key: 'clearCanvas',\n    value: function clearCanvas() {\n      this.canvasCtx.clearRect(0, 0, this.dimensions.WIDTH, this.dimensions.HEIGHT);\n    }\n\n    /**\r\n     * Update the game frame and schedules the next one.\r\n     */\n\n  }, {\n    key: 'update',\n    value: function update() {\n      this.updatePending = false;\n\n      var now = (0, _utils.getTimeStamp)();\n      var deltaTime = now - (this.time || now);\n      this.time = now;\n\n      if (this.playing) {\n        this.clearCanvas();\n\n        this.tRexGroup.updateJump(deltaTime);\n\n        this.runningTime += deltaTime;\n        var hasObstacles = this.runningTime > this.config.CLEAR_TIME;\n\n        // First time\n        if (this.isFirstTime) {\n          if (!this.activated && !this.crashed) {\n            this.playing = true;\n            this.activated = true;\n            this.startGame();\n          }\n        }\n\n        deltaTime = !this.activated ? 0 : deltaTime;\n        this.horizon.update(deltaTime, this.currentSpeed, hasObstacles);\n\n        var gameOver = false;\n        // Check for collisions.\n        if (hasObstacles) {\n          gameOver = this.tRexGroup.checkForCollision(this.horizon.obstacles[0]);\n        }\n\n        if (!gameOver) {\n          this.distanceRan += this.currentSpeed * deltaTime / this.msPerFrame;\n\n          if (this.currentSpeed < this.config.MAX_SPEED) {\n            this.currentSpeed += this.config.ACCELERATION;\n          }\n        } else {\n          this.gameOver();\n        }\n\n        this.distanceMeter.update(deltaTime, Math.ceil(this.distanceRan));\n      }\n\n      if (this.playing || !this.activated) {\n        this.tRexGroup.update(deltaTime);\n        this.scheduleNextUpdate();\n      }\n\n      var lives = this.tRexGroup.lives();\n      if (lives > 0) {\n        this.generationEl.innerText = 'GENERATION #' + Runner.generation + ' | LIVE x ' + this.tRexGroup.lives();\n      } else {\n        this.generationEl.innerHTML = '<div style=\"color: red;\">GENERATION #' + Runner.generation + '  |  GAME OVER</div>';\n      }\n    }\n\n    /**\r\n     * Bind relevant key\r\n     */\n\n  }, {\n    key: 'startListening',\n    value: function startListening() {\n      var _this = this;\n\n      document.addEventListener(Runner.events.KEYDOWN, function (e) {\n        _this.onKeyDown(e);\n      });\n      document.addEventListener(Runner.events.KEYUP, function (e) {\n        _this.onKeyUp(e);\n      });\n    }\n\n    /**\r\n     * Process keydown.\r\n     * @param {Event} e\r\n     */\n\n  }, {\n    key: 'onKeyDown',\n    value: function onKeyDown(e) {\n      if (!this.crashed && this.playing) {\n        if (Runner.keycodes.JUMP[e.keyCode]) {\n          e.preventDefault();\n          this.tRex.startJump(this.currentSpeed);\n        } else if (Runner.keycodes.DUCK[e.keyCode]) {\n          e.preventDefault();\n          if (this.tRex.jumping) {\n            // Speed drop, activated only when jump key is not pressed.\n            this.tRex.setSpeedDrop();\n          } else if (!this.tRex.jumping && !this.tRex.ducking) {\n            // Duck.\n            this.tRex.setDuck(true);\n          }\n        }\n      } else if (this.crashed) {\n        this.restart();\n      }\n    }\n\n    /**\r\n     * Process key up.\r\n     * @param {Event} e\r\n     */\n\n  }, {\n    key: 'onKeyUp',\n    value: function onKeyUp(e) {\n      var keyCode = String(e.keyCode);\n      var isJumpKey = Runner.keycodes.JUMP[keyCode];\n\n      if (this.isRunning() && isJumpKey) {\n        this.tRex.endJump();\n      } else if (Runner.keycodes.DUCK[keyCode]) {\n        this.tRex.speedDrop = false;\n        this.tRex.setDuck(false);\n      } else if (this.crashed) {\n        if (Runner.keycodes.JUMP[keyCode]) {\n          this.restart();\n        }\n      }\n    }\n\n    /**\r\n     * RequestAnimationFrame wrapper.\r\n     */\n\n  }, {\n    key: 'scheduleNextUpdate',\n    value: function scheduleNextUpdate() {\n      if (!this.updatePending) {\n        this.updatePending = true;\n        this.raqId = requestAnimationFrame(this.update.bind(this));\n      }\n    }\n\n    /**\r\n     * Whether the game is running.\r\n     * @return {boolean}\r\n     */\n\n  }, {\n    key: 'isRunning',\n    value: function isRunning() {\n      return !!this.raqId;\n    }\n\n    /**\r\n     * Game over state.\r\n     */\n\n  }, {\n    key: 'gameOver',\n    value: function gameOver() {\n      var _this2 = this;\n\n      this.stop();\n      this.crashed = true;\n      this.distanceMeter.acheivement = false;\n\n      this.tRexGroup.update(100, _Trex2.default.status.CRASHED);\n\n      // Update the high score.\n      if (this.distanceRan > this.highestScore) {\n        this.highestScore = Math.ceil(this.distanceRan);\n        this.distanceMeter.setHighScore(this.highestScore);\n      }\n\n      // Reset the time clock.\n      this.time = (0, _utils.getTimeStamp)();\n\n      setTimeout(function () {\n        _this2.restart();\n      }, 500);\n    }\n  }, {\n    key: 'stop',\n    value: function stop() {\n      this.playing = false;\n      cancelAnimationFrame(this.raqId);\n      this.raqId = 0;\n    }\n  }, {\n    key: 'play',\n    value: function play() {\n      if (!this.crashed) {\n        this.playing = true;\n        this.tRexGroup.update(0, _Trex2.default.status.RUNNING);\n        this.time = (0, _utils.getTimeStamp)();\n        this.update();\n      }\n    }\n  }, {\n    key: 'restart',\n    value: function restart() {\n      if (!this.raqId) {\n        this.playCount += 1;\n        this.runningTime = 0;\n        this.playing = true;\n        this.crashed = false;\n        this.distanceRan = 0;\n        this.setSpeed(this.config.SPEED);\n        this.time = (0, _utils.getTimeStamp)();\n        this.clearCanvas();\n        this.distanceMeter.reset(this.highestScore);\n        this.horizon.reset();\n        this.tRexGroup.reset();\n        this.config.onReset({ tRexes: this.tRexGroup.tRexes });\n        this.update();\n      } else {\n        this.isFirstTime = true;\n        this.tRexGroup.reset();\n        this.config.onReset({ tRexes: this.tRexGroup.tRexes });\n        if (!this.playing) {\n          this.playing = true;\n          this.update();\n        }\n      }\n      Runner.generation += 1;\n    }\n\n    /**\r\n     * Updates the canvas size taking into\r\n     * account the backing store pixel ratio and\r\n     * the device pixel ratio.\r\n     *\r\n     * See article by Paul Lewis:\r\n     * http://www.html5rocks.com/en/tutorials/canvas/hidpi/\r\n     *\r\n     * @param {HTMLCanvasElement} canvas\r\n     * @param {number} width\r\n     * @param {number} height\r\n     * @return {boolean} Whether the canvas was scaled.\r\n     */\n\n  }], [{\n    key: 'updateCanvasScaling',\n    value: function updateCanvasScaling(canvas, width, height) {\n      var context = canvas.getContext('2d');\n\n      // Query the various pixel ratios\n      var devicePixelRatio = Math.floor(window.devicePixelRatio) || 1;\n      var backingStoreRatio = Math.floor(context.webkitBackingStorePixelRatio) || 1;\n      var ratio = devicePixelRatio / backingStoreRatio;\n\n      // Upscale the canvas if the two ratios don't match\n      if (devicePixelRatio !== backingStoreRatio) {\n        var oldWidth = width || canvas.width;\n        var oldHeight = height || canvas.height;\n\n        canvas.width = oldWidth * ratio;\n        canvas.height = oldHeight * ratio;\n\n        canvas.style.width = oldWidth + 'px';\n        canvas.style.height = oldHeight + 'px';\n\n        // Scale the context to counter the fact that we've manually scaled\n        // our canvas element.\n        context.scale(ratio, ratio);\n        return true;\n      } else if (devicePixelRatio === 1) {\n        // Reset the canvas width / height. Fixes scaling bug when the page is\n        // zoomed and the devicePixelRatio changes accordingly.\n        canvas.style.width = canvas.width + 'px';\n        canvas.style.height = canvas.height + 'px';\n      }\n      return false;\n    }\n  }]);\n\n  return Runner;\n}();\n\n/**\r\n * Create canvas element.\r\n * @param {HTMLElement} container Element to append canvas to.\r\n * @param {number} width\r\n * @param {number} height\r\n * @param {string} className\r\n * @return {HTMLCanvasElement}\r\n */\n\n\nRunner.generation = 0;\nRunner.config = {\n  ACCELERATION: 0.001,\n  BG_CLOUD_SPEED: 0.2,\n  CLEAR_TIME: 0,\n  CLOUD_FREQUENCY: 0.5,\n  GAP_COEFFICIENT: 0.6,\n  GRAVITY: 0.6,\n  INITIAL_JUMP_VELOCITY: 12,\n  MAX_CLOUDS: 6,\n  MAX_OBSTACLE_LENGTH: 3,\n  MAX_SPEED: 13,\n  MIN_JUMP_HEIGHT: 35,\n  SPEED: 6,\n  SPEED_DROP_COEFFICIENT: 3,\n  T_REX_COUNT: 1,\n  // Events\n  onReset: noop,\n  onRunning: noop,\n  onCrash: noop\n};\nRunner.classes = {\n  CANVAS: 'game-canvas',\n  CONTAINER: 'game-container'\n};\nRunner.spriteDefinition = {\n  CACTUS_LARGE: { x: 332, y: 2 },\n  CACTUS_SMALL: { x: 228, y: 2 },\n  CLOUD: { x: 86, y: 2 },\n  HORIZON: { x: 2, y: 54 },\n  PTERODACTYL: { x: 134, y: 2 },\n  RESTART: { x: 2, y: 2 },\n  TEXT_SPRITE: { x: 655, y: 2 },\n  TREX: { x: 848, y: 2 }\n};\nRunner.keycodes = {\n  JUMP: { 38: 1, 32: 1 }, // Up, spacebar\n  DUCK: { 40: 1 // Down\n  } };\nRunner.events = {\n  ANIM_END: 'webkitAnimationEnd',\n  CLICK: 'click',\n  KEYDOWN: 'keydown',\n  KEYUP: 'keyup',\n  RESIZE: 'resize',\n  VISIBILITY: 'visibilitychange',\n  BLUR: 'blur',\n  FOCUS: 'focus',\n  LOAD: 'load'\n};\nexports.default = Runner;\nfunction createCanvas(container, width, height, className) {\n  var canvas = document.createElement('canvas');\n  canvas.className = className ? Runner.classes.CANVAS + ' ' + className : Runner.classes.CANVAS;\n  canvas.width = width;\n  canvas.height = height;\n  container.appendChild(canvas);\n\n  return canvas;\n}\n\nfunction noop() {}\n\n//# sourceURL=webpack:///./game/Runner.js?");

/***/ }),

/***/ "./game/RuntimeConfig.js":
/*!*******************************!*\
  !*** ./game/RuntimeConfig.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getFPS = getFPS;\nexports.setFPS = setFPS;\nvar FPS = 60;\n\nfunction getFPS() {\n  return FPS;\n}\n\nfunction setFPS(value) {\n  FPS = value;\n}\n\n//# sourceURL=webpack:///./game/RuntimeConfig.js?");

/***/ }),

/***/ "./game/Trex.js":
/*!**********************!*\
  !*** ./game/Trex.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.checkForCollision = checkForCollision;\n\nvar _constants = __webpack_require__(/*! ./constants */ \"./game/constants.js\");\n\nvar _RuntimeConfig = __webpack_require__(/*! ./RuntimeConfig */ \"./game/RuntimeConfig.js\");\n\nvar _ImageSprite = __webpack_require__(/*! ./ImageSprite */ \"./game/ImageSprite.js\");\n\nvar _utils = __webpack_require__(/*! ./utils */ \"./game/utils.js\");\n\nvar _CollisionBox = __webpack_require__(/*! ./CollisionBox */ \"./game/CollisionBox.js\");\n\nvar _CollisionBox2 = _interopRequireDefault(_CollisionBox);\n\nvar _Runner = __webpack_require__(/*! ./Runner */ \"./game/Runner.js\");\n\nvar _Runner2 = _interopRequireDefault(_Runner);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * T-rex game character.\r\n * @param {HTMLCanvas} canvas\r\n * @param {Object} spritePos Positioning within image sprite.\r\n * @constructor\r\n */\nvar Trex = function () {\n\n  /**\r\n   * Blinking coefficient.\r\n   * @const\r\n   */\n\n\n  /**\r\n   * Used in collision detection.\r\n   * @type {Array<CollisionBox>}\r\n   */\n  function Trex(canvas, spritePos) {\n    _classCallCheck(this, Trex);\n\n    this.canvas = canvas;\n    this.canvasCtx = canvas.getContext('2d');\n    this.spritePos = spritePos;\n    this.xPos = 0;\n    this.yPos = 0;\n    // Position when on the ground.\n    this.groundYPos = 0;\n    this.currentFrame = 0;\n    this.currentAnimFrames = [];\n    this.blinkDelay = 0;\n    this.blinkCount = 0;\n    this.animStartTime = 0;\n    this.timer = 0;\n    this.msPerFrame = 1000 / (0, _RuntimeConfig.getFPS)();\n    this.config = Trex.config;\n    // Current status.\n    this.status = Trex.status.WAITING;\n\n    this.jumping = false;\n    this.ducking = false;\n    this.jumpVelocity = 0;\n    this.reachedMinHeight = false;\n    this.speedDrop = false;\n    this.jumpCount = 0;\n    this.jumpspotX = 0;\n\n    this.init();\n  }\n\n  /**\r\n   * T-rex player initaliser.\r\n   * Sets the t-rex to blink at random intervals.\r\n   */\n\n\n  /**\r\n   * Animation config for different states.\r\n   * @enum {Object}\r\n   */\n\n\n  /**\r\n   * Animation states.\r\n   * @enum {string}\r\n   */\n\n\n  _createClass(Trex, [{\n    key: 'init',\n    value: function init() {\n      this.groundYPos = _constants.CANVAS_HEIGHT - this.config.HEIGHT - _constants.RUNNER_BOTTOM_PAD;\n      this.yPos = this.groundYPos;\n      this.minJumpHeight = this.groundYPos - this.config.MIN_JUMP_HEIGHT;\n\n      this.draw(0, 0);\n      this.update(0, Trex.status.WAITING);\n    }\n\n    /**\r\n     * Setter for the jump velocity.\r\n     * The approriate drop velocity is also set.\r\n     */\n\n  }, {\n    key: 'setJumpVelocity',\n    value: function setJumpVelocity(setting) {\n      this.config.INIITAL_JUMP_VELOCITY = -setting;\n      this.config.DROP_VELOCITY = -setting / 2;\n    }\n\n    /**\r\n     * Set the animation status.\r\n     * @param {!number} deltaTime\r\n     * @param {Trex.status} status Optional status to switch to.\r\n     */\n\n  }, {\n    key: 'update',\n    value: function update(deltaTime, status) {\n      this.timer += deltaTime;\n\n      // Update the status.\n      if (status) {\n        this.status = status;\n        this.currentFrame = 0;\n        this.msPerFrame = Trex.animFrames[status].msPerFrame;\n        this.currentAnimFrames = Trex.animFrames[status].frames;\n\n        if (status === Trex.status.WAITING) {\n          this.animStartTime = (0, _utils.getTimeStamp)();\n          this.setBlinkDelay();\n        }\n      }\n\n      if (this.status === Trex.status.WAITING) {\n        this.blink((0, _utils.getTimeStamp)());\n      } else {\n        this.draw(this.currentAnimFrames[this.currentFrame], 0);\n      }\n\n      // Update the frame position.\n      if (this.timer >= this.msPerFrame) {\n        this.currentFrame = this.currentFrame === this.currentAnimFrames.length - 1 ? 0 : this.currentFrame + 1;\n        this.timer = 0;\n      }\n\n      // Speed drop becomes duck if the down key is still being pressed.\n      if (this.speedDrop && this.yPos === this.groundYPos) {\n        this.speedDrop = false;\n        this.setDuck(true);\n      }\n    }\n\n    /**\r\n     * Draw the t-rex to a particular position.\r\n     * @param {number} x\r\n     * @param {number} y\r\n     */\n\n  }, {\n    key: 'draw',\n    value: function draw(x, y) {\n      var sourceX = x;\n      var sourceY = y;\n      var sourceWidth = this.ducking && this.status !== Trex.status.CRASHED ? this.config.WIDTH_DUCK : this.config.WIDTH;\n      var sourceHeight = this.config.HEIGHT;\n\n      // Adjustments for sprite sheet position.\n      sourceX += this.spritePos.x;\n      sourceY += this.spritePos.y;\n\n      // Ducking.\n      if (this.ducking && this.status !== Trex.status.CRASHED) {\n        this.canvasCtx.drawImage((0, _ImageSprite.getImageSprite)(), sourceX, sourceY, sourceWidth, sourceHeight, this.xPos, this.yPos, this.config.WIDTH_DUCK, this.config.HEIGHT);\n      } else {\n        // Crashed whilst ducking. Trex is standing up so needs adjustment.\n        if (this.ducking && this.status === Trex.status.CRASHED) {\n          this.xPos += 1;\n        }\n        // Standing / running\n        this.canvasCtx.drawImage((0, _ImageSprite.getImageSprite)(), sourceX, sourceY, sourceWidth, sourceHeight, this.xPos, this.yPos, this.config.WIDTH, this.config.HEIGHT);\n      }\n    }\n\n    /**\r\n     * Sets a random time for the blink to happen.\r\n     */\n\n  }, {\n    key: 'setBlinkDelay',\n    value: function setBlinkDelay() {\n      this.blinkDelay = Math.ceil(Math.random() * Trex.BLINK_TIMING);\n    }\n\n    /**\r\n     * Make t-rex blink at random intervals.\r\n     * @param {number} time Current time in milliseconds.\r\n     */\n\n  }, {\n    key: 'blink',\n    value: function blink(time) {\n      var deltaTime = time - this.animStartTime;\n\n      if (deltaTime >= this.blinkDelay) {\n        this.draw(this.currentAnimFrames[this.currentFrame], 0);\n\n        if (this.currentFrame === 1) {\n          // Set new random delay to blink.\n          this.setBlinkDelay();\n          this.animStartTime = time;\n          this.blinkCount += 1;\n        }\n      }\n    }\n\n    /**\r\n     * Initialise a jump.\r\n     * @param {number} speed\r\n     */\n\n  }, {\n    key: 'startJump',\n    value: function startJump(speed) {\n      if (speed === undefined) {\n        speed = _Runner2.default.instance_.currentSpeed;\n      }\n      if (!this.jumping) {\n        this.update(0, Trex.status.JUMPING);\n        // Tweak the jump velocity based on the speed.\n        this.jumpVelocity = this.config.INIITAL_JUMP_VELOCITY - speed / 10;\n        this.jumping = true;\n        this.reachedMinHeight = false;\n        this.speedDrop = false;\n      }\n    }\n\n    /**\r\n     * Jump is complete, falling down.\r\n     */\n\n  }, {\n    key: 'endJump',\n    value: function endJump() {\n      if (this.reachedMinHeight && this.jumpVelocity < this.config.DROP_VELOCITY) {\n        this.jumpVelocity = this.config.DROP_VELOCITY;\n      }\n    }\n\n    /**\r\n     * Update frame for a jump.\r\n     * @param {number} deltaTime\r\n     * @param {number} speed\r\n     */\n\n  }, {\n    key: 'updateJump',\n    value: function updateJump(deltaTime, speed) {\n      var msPerFrame = Trex.animFrames[this.status].msPerFrame;\n\n      var framesElapsed = deltaTime / msPerFrame;\n\n      // Speed drop makes Trex fall faster.\n      if (this.speedDrop) {\n        this.yPos += Math.round(this.jumpVelocity * this.config.SPEED_DROP_COEFFICIENT * framesElapsed);\n      } else {\n        this.yPos += Math.round(this.jumpVelocity * framesElapsed);\n      }\n\n      this.jumpVelocity += this.config.GRAVITY * framesElapsed;\n\n      // Minimum height has been reached.\n      if (this.yPos < this.minJumpHeight || this.speedDrop) {\n        this.reachedMinHeight = true;\n      }\n\n      // Reached max height\n      if (this.yPos < this.config.MAX_JUMP_HEIGHT || this.speedDrop) {\n        this.endJump();\n      }\n\n      // Back down at ground level. Jump completed.\n      if (this.yPos > this.groundYPos) {\n        this.reset();\n        this.jumpCount += 1;\n      }\n\n      this.update(deltaTime);\n    }\n\n    /**\r\n     * Set the speed drop. Immediately cancels the current jump.\r\n     */\n\n  }, {\n    key: 'setSpeedDrop',\n    value: function setSpeedDrop() {\n      this.speedDrop = true;\n      this.jumpVelocity = 1;\n    }\n\n    /**\r\n     * @param {boolean} isDucking.\r\n     */\n\n  }, {\n    key: 'setDuck',\n    value: function setDuck(isDucking) {\n      if (isDucking && this.status !== Trex.status.DUCKING) {\n        this.update(0, Trex.status.DUCKING);\n        this.ducking = true;\n      } else if (this.status === Trex.status.DUCKING) {\n        this.update(0, Trex.status.RUNNING);\n        this.ducking = false;\n      }\n    }\n\n    /**\r\n     * Reset the t-rex to running at start of game.\r\n     */\n\n  }, {\n    key: 'reset',\n    value: function reset() {\n      this.yPos = this.groundYPos;\n      this.jumpVelocity = 0;\n      this.jumping = false;\n      this.ducking = false;\n      this.update(0, Trex.status.RUNNING);\n      this.midair = false;\n      this.speedDrop = false;\n      this.jumpCount = 0;\n      this.crashed = false;\n    }\n  }]);\n\n  return Trex;\n}();\n\n/**\r\n * Check for a collision.\r\n * @param {!Obstacle} obstacle\r\n * @param {!Trex} tRex T-rex object.\r\n * @param {HTMLCanvasContext} canvasContext Optional canvas context for drawing\r\n *    collision boxes.\r\n * @return {Array<CollisionBox>}\r\n */\n\n\nTrex.config = {\n  DROP_VELOCITY: -5,\n  GRAVITY: 0.6,\n  HEIGHT: 47,\n  HEIGHT_DUCK: 25,\n  INIITAL_JUMP_VELOCITY: -10,\n  MAX_JUMP_HEIGHT: 30,\n  MIN_JUMP_HEIGHT: 30,\n  SPEED_DROP_COEFFICIENT: 3,\n  SPRITE_WIDTH: 262,\n  START_X_POS: 50,\n  WIDTH: 44,\n  WIDTH_DUCK: 59\n};\nTrex.collisionBoxes = {\n  DUCKING: [new _CollisionBox2.default(1, 18, 55, 25)],\n  RUNNING: [new _CollisionBox2.default(22, 0, 17, 16), new _CollisionBox2.default(1, 18, 30, 9), new _CollisionBox2.default(10, 35, 14, 8), new _CollisionBox2.default(1, 24, 29, 5), new _CollisionBox2.default(5, 30, 21, 4), new _CollisionBox2.default(9, 34, 15, 4)]\n};\nTrex.status = {\n  CRASHED: 'CRASHED',\n  DUCKING: 'DUCKING',\n  JUMPING: 'JUMPING',\n  RUNNING: 'RUNNING',\n  WAITING: 'WAITING'\n};\nTrex.BLINK_TIMING = 7000;\nTrex.animFrames = {\n  WAITING: {\n    frames: [44, 0],\n    msPerFrame: 1000 / 3\n  },\n  RUNNING: {\n    frames: [88, 132],\n    msPerFrame: 1000 / 12\n  },\n  CRASHED: {\n    frames: [220],\n    msPerFrame: 1000 / 60\n  },\n  JUMPING: {\n    frames: [0],\n    msPerFrame: 1000 / 60\n  },\n  DUCKING: {\n    frames: [262, 321],\n    msPerFrame: 1000 / 8\n  }\n};\nexports.default = Trex;\nfunction checkForCollision(obstacle, tRex) {\n  var obstacleBoxXPos = _constants.CANVAS_WIDTH + obstacle.xPos;\n\n  // Adjustments are made to the bounding box as there is a 1 pixel white\n  // border around the t-rex and obstacles.\n  var tRexBox = new _CollisionBox2.default(tRex.xPos + 1, tRex.yPos + 1, tRex.config.WIDTH - 2, tRex.config.HEIGHT - 2);\n\n  var obstacleBox = new _CollisionBox2.default(obstacle.xPos + 1, obstacle.yPos + 1, obstacle.typeConfig.width * obstacle.size - 2, obstacle.typeConfig.height - 2);\n\n  // Simple outer bounds check.\n  if (boxCompare(tRexBox, obstacleBox)) {\n    var collisionBoxes = obstacle.collisionBoxes;\n\n    var tRexCollisionBoxes = tRex.ducking ? Trex.collisionBoxes.DUCKING : Trex.collisionBoxes.RUNNING;\n\n    // Detailed axis aligned box check.\n    for (var t = 0; t < tRexCollisionBoxes.length; t += 1) {\n      for (var i = 0; i < collisionBoxes.length; i += 1) {\n        // Adjust the box to actual positions.\n        var adjTrexBox = createAdjustedCollisionBox(tRexCollisionBoxes[t], tRexBox);\n        var adjObstacleBox = createAdjustedCollisionBox(collisionBoxes[i], obstacleBox);\n        var crashed = boxCompare(adjTrexBox, adjObstacleBox);\n\n        if (crashed) {\n          return [adjTrexBox, adjObstacleBox];\n        }\n      }\n    }\n  }\n  return false;\n}\n\n/**\r\n * Adjust the collision box.\r\n * @param {!CollisionBox} box The original box.\r\n * @param {!CollisionBox} adjustment Adjustment box.\r\n * @return {CollisionBox} The adjusted collision box object.\r\n */\nfunction createAdjustedCollisionBox(box, adjustment) {\n  return new _CollisionBox2.default(box.x + adjustment.x, box.y + adjustment.y, box.width, box.height);\n}\n\n/**\r\n * Compare two collision boxes for a collision.\r\n * @param {CollisionBox} tRexBox\r\n * @param {CollisionBox} obstacleBox\r\n * @return {boolean} Whether the boxes intersected.\r\n */\nfunction boxCompare(tRexBox, obstacleBox) {\n  var crashed = false;\n  var tRexBoxX = tRexBox.x;\n  var tRexBoxY = tRexBox.y;\n\n  var obstacleBoxX = obstacleBox.x;\n  var obstacleBoxY = obstacleBox.y;\n\n  // Axis-Aligned Bounding Box method.\n  if (tRexBox.x < obstacleBoxX + obstacleBox.width && tRexBox.x + tRexBox.width > obstacleBoxX && tRexBox.y < obstacleBox.y + obstacleBox.height && tRexBox.height + tRexBox.y > obstacleBox.y) {\n    crashed = true;\n  }\n\n  return crashed;\n}\n\n//# sourceURL=webpack:///./game/Trex.js?");

/***/ }),

/***/ "./game/TrexGroup.js":
/*!***************************!*\
  !*** ./game/TrexGroup.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Runner = __webpack_require__(/*! ./Runner */ \"./game/Runner.js\");\n\nvar _Runner2 = _interopRequireDefault(_Runner);\n\nvar _Trex = __webpack_require__(/*! ./Trex */ \"./game/Trex.js\");\n\nvar _Trex2 = _interopRequireDefault(_Trex);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar TrexGroup = function () {\n  function TrexGroup(count, canvas, spriteDef) {\n    _classCallCheck(this, TrexGroup);\n\n    this.onReset = noop;\n    this.onRunning = noop;\n    this.onCrash = noop;\n\n    this.tRexes = [];\n    for (var i = 0; i < count; i += 1) {\n      var tRex = new _Trex2.default(canvas, spriteDef);\n      tRex.id = i;\n      this.tRexes.push(tRex);\n    }\n  }\n\n  _createClass(TrexGroup, [{\n    key: 'update',\n    value: function update(deltaTime, status) {\n      this.tRexes.forEach(function (tRex) {\n        if (!tRex.crashed) {\n          tRex.update(deltaTime, status);\n        }\n      });\n    }\n  }, {\n    key: 'draw',\n    value: function draw(x, y) {\n      this.tRexes.forEach(function (tRex) {\n        if (!tRex.crashed) {\n          tRex.draw(x, y);\n        }\n      });\n    }\n  }, {\n    key: 'updateJump',\n    value: function updateJump(deltaTime, speed) {\n      this.tRexes.forEach(function (tRex) {\n        if (tRex.jumping) {\n          tRex.updateJump(deltaTime, speed);\n        }\n      });\n    }\n  }, {\n    key: 'reset',\n    value: function reset() {\n      var _this = this;\n\n      this.tRexes.forEach(function (tRex) {\n        tRex.reset();\n        _this.onReset({ tRex: tRex });\n      });\n    }\n  }, {\n    key: 'lives',\n    value: function lives() {\n      return this.tRexes.reduce(function (count, tRex) {\n        return tRex.crashed ? count : count + 1;\n      }, 0);\n    }\n  }, {\n    key: 'checkForCollision',\n    value: function checkForCollision(obstacle) {\n      var _this2 = this;\n\n      var crashes = 0;\n      var state = {\n        obstacleX: obstacle.xPos,\n        obstacleY: obstacle.yPos,\n        obstacleWidth: obstacle.width,\n        speed: _Runner2.default.instance_.currentSpeed\n      };\n      this.tRexes.forEach(function () {\n        var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(tRex) {\n          var result, action;\n          return regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  if (tRex.crashed) {\n                    _context.next = 14;\n                    break;\n                  }\n\n                  result = (0, _Trex.checkForCollision)(obstacle, tRex);\n\n                  if (!result) {\n                    _context.next = 8;\n                    break;\n                  }\n\n                  crashes += 1;\n                  tRex.crashed = true;\n                  _this2.onCrash({ tRex: tRex, state: state });\n                  _context.next = 12;\n                  break;\n\n                case 8:\n                  _context.next = 10;\n                  return _this2.onRunning({ tRex: tRex, state: state });\n\n                case 10:\n                  action = _context.sent;\n\n                  if (action === 1) {\n                    tRex.startJump();\n                  } else if (action === -1) {\n                    if (tRex.jumping) {\n                      // Speed drop, activated only when jump key is not pressed.\n                      tRex.setSpeedDrop();\n                    } else if (!tRex.jumping && !tRex.ducking) {\n                      // Duck.\n                      tRex.setDuck(true);\n                    }\n                  }\n\n                case 12:\n                  _context.next = 15;\n                  break;\n\n                case 14:\n                  crashes += 1;\n\n                case 15:\n                case 'end':\n                  return _context.stop();\n              }\n            }\n          }, _callee, _this2);\n        }));\n\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n      return crashes === this.tRexes.length;\n    }\n  }]);\n\n  return TrexGroup;\n}();\n\nexports.default = TrexGroup;\n\n\nfunction noop() {}\n\n//# sourceURL=webpack:///./game/TrexGroup.js?");

/***/ }),

/***/ "./game/constants.js":
/*!***************************!*\
  !*** ./game/constants.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Default game canvas size.\r\n */\nvar CANVAS_WIDTH = exports.CANVAS_WIDTH = 600;\nvar CANVAS_HEIGHT = exports.CANVAS_HEIGHT = 150;\n\n/**\r\n * Runner configs\r\n*/\nvar RUNNER_BOTTOM_PAD = exports.RUNNER_BOTTOM_PAD = 10;\nvar RUNNER_MAX_OBSTACLE_DUPLICATION = exports.RUNNER_MAX_OBSTACLE_DUPLICATION = 2;\n\n//# sourceURL=webpack:///./game/constants.js?");

/***/ }),

/***/ "./game/images/offline-sprite.png":
/*!****************************************!*\
  !*** ./game/images/offline-sprite.png ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABNEAAABECAAAAACKI/xBAAAAAnRSTlMAAHaTzTgAAAoOSURBVHgB7J1bdqS4FkSDu7gPTYSh2AOATw1Pn6kBVA2FieiTrlesq6po8lgt0pj02b06E58HlRhXOCQBBcdxHMdxHOfDMeA7BfcIOI4VwISDKQhvK0O4H9iAobeFZSx8WIK0dqz4ztQRg1XdECNfX/CTGUDmNjJDP6MzuMnKKsQ0Y+Amyxnirurmx1KghAvWXoARAErEPUpAB/KzvK6YcAIl8lD2AtsCbENPS1XGwqMTSnvHhNOYgBV3mKlklKDqPUshMUIzsuzlOXFGW9AQS0C/lv/QMWrahOMoiKZL41HyUCRAdcKyDR0tVRkLD0+oV7Q7yLofm6w6rKbdrmNUL6NOyapMtGcUuixZ2WSHbsl+M97BoUX8TrpyrfGbJJ+saBQ0W9I6jnxF/ZO+4nqo66GQneo325keUjth7bFpX38MO6lbM+ZMaeOYETISzYzN9Wiy7shuyj4dI96JSQXuOMSlWcqkgQ2DSlVdUSIbWbVs2vJ41CvadDs0jTE63Y9NWO26r3x9MU3AzDGk1mQWZu2Bht6VaPzEXrl21gjyZRXNPnKFI8+TJnRKLEED24JNpaqqKBGx/C5oWLSlBR0+Pp4J5yM27YVydp8sX4p+SUGe661TuWE5Y78dtcDSX3u+oqWINjLmRm+wTsBUJWpK06pKaXZpJdbmhoH/LcByq6Rq+LMC+7Dl+OFjvzj2ObRJY/tOa1r/uUvDy9d9QaPz4utMP6ZDysxsPeScf3yly6bOfRbcemtPYESvpAn20GSS0efVKOGc4aNQgojj1ZnzvTEnkxqzOVfGllP3y9qnZ0S3pM2mK5jMwQcpiMb1ZVqdkBANl1aCFbBbdOR6Pvwgtjiu9vkx60jrXNpq15E8ywhz/2tbzGQQwQ4b59Zfe7aipVrSEhCP8mZG1UlzZ20tOgw9Hw6hrzCLZiyObqCkVauZFC0OPL8nqUrk/zHN1gopOfkzngH3fv8SQau20jtMQ09VUSmxQUS1OsZSDAWSwKNFq5SylzA6PhFf+Oo4x3m0pEuYKXb4s5WLAAaT1lwfc3Kr6CDZ6JD6hrUCWVhmjHFrzNk17pxWjdGl/Yi9AuBrBqAbusmvGNNCyWpbhvPU82j1aDMi9Q04p8aLaQtiw7plXZ0A7TwDSojO/GsCiAnE6qAGhg45/eAu7csrunGcEUpEN5NsXYDlUY6Mie67UGPTPiiO1xl0vgLYvXt83glmvkux7ke6WdGzz7mKmiSQM2ufmPEoQUv9d2fu3jEazGqc79JUQjRxghoZT9FoiJnjzvbYtDJGOXOcoxUt4hMybAucE3nloJPOSJh5v6cm8gwFWrnn72aj1txnvR+5RrzoXy8kBOAStWBtw/foGvd1NnyX+h2a+LXQUH2XKAFT0uLpi9byzXg2vrzy9Z6eAZmqIUnHoaJ9PlIofwaAYQMWu6XituAE6vWBgifhla/Xp3ClqjpFESRdt5Z+WCIkQ68vHNBAXysZH3CmuufhInRurCagvLk6QNXpbwMDNvouu+Vn/fLeVo3rA084PzAYiwDtzB1jIB3Jmvuc0YqzQRk6W0d8LhIQ9gPkNhSpEGjr2HKW4XyOuznthx/M+8V/W5+7/vRZ9yARQ4L5a18IIBetJbN18/oGYNjRHwyHt6qiJSj9R25zZ55M7Uiq6u3qglDF2KmBCqqTVqhNO0bQSp+gxRJkV9fi68uP/z8TzgYd3tyw9bQOqBUtpmdd9wwlGoGKGzDstMR7LR1EtENp582d1z5jL3yGrc79y83pSsbBZHquNluXZd5DfteKbbhaLc+Ongp1tUslUUvDve1drSPuSFoE2o/8AIL6rspChrbqZkkb0N5yhNa2E3B95Bm2vN+8m/me3lE9WaGp3LbPPDc/u9VZoJFbZ+uoCvaMhAJEDTS2xOO/Tdzp+Xs6C3mG7fXhnXlR4gnx4rXU7dma/FTl0YS29beOjztTx6NOUF2aVrNEe/bZa4m6+nmuEJUAbnFP15xH+/7fHU/FYG6LG+SmVL5bmnFZ/Ho0J4WP4NK4KMCtS7u0p/Bo9ngnXbfWXnVu/DcNdGf9rRgfeab6sWfR1KXZ1Z0kY7+l3rIToQCImiD2U9y4FepFaHm44jpJjDTGlOmfxVbGHMc92nkEW/PrrRSKJiqjF4CiHaqBNqEuLPxDLsGL/+xcvFavbLph6W89TdHCw5wZCW2zXggfe4Sqcc2oBhYYSAc+EY4zGhM5/teid0osBSaaBC3F/vPAjvpxsdDx5Dp1jjsnI7Y+95hT5z+erpZkzB/dpY2wJS0FPfLH0/wsj/AhJS0FJuTaWOPbHWFbN/9VdCUSwtPW5g81j2aMZULDkbtLE+GSBKOCdGiCURtVTXFpp7KCuEtzl3braVVFQ+g/8n6eQil/X24MmjAIe+oYJNqwK2M8uU5mXc8652rXOY6vdZ6NvdyoiXZ1jBqNcC7o0tKVaw2XlltdGs0VUwsYGTpbxwPO1JXcU7gTGLYfrx0tx6tjsW/PsjHd14p2l+YOzXGPdirBDAwdLe9sAf54IEh86zLA2qQj64SGYp9EM674Dk9Rqy4tY58B2MRqVRZOIr2t44FnymfRzlyJSOHBLg2rOzSnn5vxjI3O1hHXxyVNb8zqt2mNi6OrGzR9egPfH1QLREQgFSDs17Ky/zOoS+O7wVJNfN1axjh108L93G8dH3umelx7gGMTCuLbbfJEQZEYha6KGTbN9l2r+zNn2xkwLnzorNWqsLVP0eaGXMZ74pLWDNXLL0N7+GRnAmdqwgNqE4O7tQkREQmp+zMoudWlATcMaIRN28ErA5nv9pF/6PtEnak/1r8H53lRR6bcfuYe0DrCcZxL3vdk19PHBZQz73u6AT0ODZWGbTAY33Ud0nEcZ3hg64gmZjiO81YiCkK1dXytBauO/wwzsmxBqc3VIhP6DVNw5FhFywDS24/cKeHRCdLfoTiO3zMw58+uYUX/HYD2BLETinY4Z5Bk6+jaFo79DFm3LG4Q+pr6r97I5pH7pRsllgiQUEJ7QsSRCdN2aYfjuEczNDnollPLSKm/7EhQ6pgQ2yUKpx3OaQTZOra2gf7P0M/Q3+ScTJlLX6KgECb49h02lFLudPzVzn0lNQwEURQdrfGuc9anX34AIzk21c/xHjLYCo/JU2W1kLTm/7BeP7kkSZIkZbj0JhHZgDdAg5UeAA6f9f8Ar//eMZqUxs8ggs7BhAEarPQAsPm+hwFus4SnG6Mx3pI0xwEX/syoMMDteO0x17QlCd5m/CbX0STs9m3RDggXBLpKWv5S83eSF787y1Wd5apuCcXDHFu0HL1wPGbhz6lL2WL2VYrtE6NPZW7usXAEy1WZ5epGInCMMLhTBsCQ5erTyhXVlAASQROIjO0FvHBFh+evzparEMvVsp8XMGZ5HuHL3cZGzpu884kxZtN/1HLVynL1uiRJkvQFUg1OaKSaqSkAAAAASUVORK5CYII=\"\n\n//# sourceURL=webpack:///./game/images/offline-sprite.png?");

/***/ }),

/***/ "./game/index.js":
/*!***********************!*\
  !*** ./game/index.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Runner = undefined;\n\nvar _Runner = __webpack_require__(/*! ./Runner */ \"./game/Runner.js\");\n\nObject.defineProperty(exports, 'Runner', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_Runner).default;\n  }\n});\n\n__webpack_require__(/*! ./index.less */ \"./game/index.less\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n//# sourceURL=webpack:///./game/index.js?");

/***/ }),

/***/ "./game/index.less":
/*!*************************!*\
  !*** ./game/index.less ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../../node_modules/css-loader/dist/cjs.js!../../node_modules/less-loader/dist/cjs.js!./index.less */ \"../node_modules/css-loader/dist/cjs.js!../node_modules/less-loader/dist/cjs.js!./game/index.less\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ \"../node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}\n\n//# sourceURL=webpack:///./game/index.less?");

/***/ }),

/***/ "./game/utils.js":
/*!***********************!*\
  !*** ./game/utils.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getTimeStamp = getTimeStamp;\nexports.getRandomNum = getRandomNum;\n/**\r\n * Return the current timestamp.\r\n * @return {number}\r\n */\nfunction getTimeStamp() {\n  return performance.now();\n}\n\n/**\r\n * Get random number.\r\n * @param {number} min\r\n * @param {number} max\r\n * @param {number}\r\n */\nfunction getRandomNum(min, max) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\n//# sourceURL=webpack:///./game/utils.js?");

/***/ }),

/***/ 6:
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//# sourceURL=webpack:///crypto_(ignored)?");

/***/ }),

/***/ 8:
/*!******************************************************************************************!*\
  !*** multi ../node_modules/webpack-dev-server/client?http://localhost:8080 ./apps/nn.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! D:\\Code\\tensorflow-rex-run\\node_modules\\webpack-dev-server\\client\\index.js?http://localhost:8080 */\"../node_modules/webpack-dev-server/client/index.js?http://localhost:8080\");\nmodule.exports = __webpack_require__(/*! ./apps/nn.js */\"./apps/nn.js\");\n\n\n//# sourceURL=webpack:///multi_../node_modules/webpack-dev-server/client?");

/***/ })

/******/ });